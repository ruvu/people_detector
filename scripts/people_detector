#!/usr/bin/env python
from cv_bridge import CvBridge
from itertools import groupby

import message_filters
import numpy
import rospy
from image_recognition_msgs.srv import Recognize
from sensor_msgs.msg import Image, CameraInfo
import image_geometry


class PeopleDetector(object):
    padding = 5

    def __init__(self):
        rospy.loginfo('starting people_detector')
        self.bridge = CvBridge()

        depth_info_sub = message_filters.Subscriber('depth/camera_info', CameraInfo)
        depth_sub = message_filters.Subscriber('depth/image', Image)
        rgb_sub = message_filters.Subscriber('rgb/image', Image)

        self._ts = message_filters.TimeSynchronizer([depth_info_sub, rgb_sub, depth_sub], 10)
        self._ts.registerCallback(self.callback)

        self.recognize = rospy.ServiceProxy('/recognize', Recognize)

    def callback(self, depth_info, rgb, depth):
        rospy.loginfo('got image cb')
        assert rgb.width == depth.width
        assert rgb.height == depth.height
        # print rgb.header, depth.header

        cv_depth = self.bridge.imgmsg_to_cv2(depth)

        data = self.recognize(image=rgb)
        for group_id, recognitions in groupby(data.recognitions, lambda r: r.group_id):
            recognitions = list(recognitions)
            rospy.loginfo('found %s objects for group %s', len(recognitions), group_id)

            for r in recognitions:
                roi = r.roi
                x_min = roi.x_offset - self.padding
                x_max = roi.x_offset + roi.width + self.padding
                y_min = roi.y_offset - self.padding
                y_max = roi.y_offset + roi.height + self.padding

                if x_min < 0 or y_min < 0 or x_max > depth.width or y_max > depth.height:
                    continue  # outside of the image

                region = cv_depth[x_min:x_max, y_min:y_max]
                median = numpy.median(region)

                rospy.loginfo('region min=%f, max=%f, median=%f', region.min(), region.max(), median)

                # project to 3d
                u = roi.x_offset + roi.width // 2
                v = roi.y_offset + roi.height // 2
                d = median
                cam_model = image_geometry.PinholeCameraModel()
                cam_model.fromCameraInfo(depth_info)
                ray = numpy.array(cam_model.projectPixelTo3dRay((u, v)))
                point3d = ray * d

                rospy.loginfo('3d point of pixel %d,%d: %s', u, v, point3d)

if __name__ == '__main__':
    rospy.init_node('people_detector')
    PeopleDetector()
    rospy.spin()
